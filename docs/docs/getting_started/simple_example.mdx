---
sidebar_position: 1
---

# A Simple Example

Here we look at a simple optimization algorithm (the steepest descent) and use it to solve a simple unconstrained 
optimization problem.

Given an initial guess $x_0$, the steepest descent computes the new iterate recursively by using the formula

$x_{k+1} = x_{k} - \nabla f(x_k)$

## Developing the optimizer


```
import numpy as np
import time

from modopt.api import Optimizer


class SteepestDescent(Optimizer):

    def initialize(self):
        # Name your algorithm
        self.solver = 'steepest_descent'

    def run(self):
        nx = self.options['nx']
        x0 = self.options['x0']
        opt_tol = self.options['opt_tol']
        max_itr = self.options['max_itr']

        obj = self.obj
        grad = self.grad

        start_time = time.time()

        # student's code starts here

        # Setting intial values for current iterates
        x_k = x0 * 1.
        f_k = obj(x_k)
        g_k = grad(x_k)
        
        # Setting intial values for computed new iterates
        f_new = f_k * 1
        g_new = g_k * 1
        
        itr = 0

        # Initializing result arrays
        num_f_evals_array = np.array([1])
        num_g_evals_array = np.array([1])
        x_array = x0.reshape(1, nx)
        obj_array = np.array([f_k * 1.])
        opt_array = np.array([np.linalg.norm(g_k)])
        step_array = np.array([0.,])
        time_array = np.array([time.time() - start_time])
        
        while (opt_array[-1] > opt_tol and itr < max_itr):
            start = time.time()
            itr += 1

            p_k =  -g_k   
        
            x_k += p_k
            f_k = obj(x_k)
            g_k = grad(x_k)

            x_array = np.append(x_array, x_k.reshape(1, nx), axis=0)
            obj_array = np.append(obj_array, f_k)
            opt_array = np.append(opt_array, np.linalg.norm(g_k))
            end = time.time()
            time_array = np.append(time_array, [time_array[-1] + end - start])

        end_time = time.time()
        itr_array = np.arange(itr + 1)
        self.total_time = end_time - start_time

        self.results['x_array'] = x_array
        self.results['itr_array'] = itr_array
        self.results['obj_array'] = obj_array
        self.results['opt_array'] = opt_array
        self.results['time_array'] = time_array


```